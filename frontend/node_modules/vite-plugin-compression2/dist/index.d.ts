import { Plugin } from 'vite';
import { ZlibOptions, BrotliOptions } from 'zlib';

type Algorithm = 'gzip' | 'brotliCompress' | 'deflate' | 'deflateRaw';
interface UserCompressionOptions {
    [key: string]: any;
}
type InferDefault<T> = T extends infer K ? K : UserCompressionOptions;
type CompressionOptions<T> = InferDefault<T>;
interface BaseCompressionPluginOptions {
    include?: string | RegExp | Array<string | RegExp>;
    exclude?: RegExp | string | Array<string | RegExp>;
    threshold?: number;
    filename?: string | ((id: string) => string);
    deleteOriginalAssets?: boolean;
    skipIfLargerOrEqual?: boolean;
}

interface AlgorithmToZlib {
    gzip: ZlibOptions;
    brotliCompress: BrotliOptions;
    deflate: ZlibOptions;
    deflateRaw: ZlibOptions;
}
type AlgorithmFunction<T> = (buf: Buffer, options: CompressionOptions<T>, callback: (err: Error | null, result: Buffer) => void) => void;
type InternalCompressionPluginOptionsFunction<T> = {
    algorithm?: AlgorithmFunction<T>;
    compressionOptions?: CompressionOptions<T>;
};
type InternalCompressionPluginOptionsAlgorithm<A extends Algorithm> = {
    algorithm?: A;
    compressionOptions?: AlgorithmToZlib[A];
};
type ViteCompressionPluginConfigFunction<T> = BaseCompressionPluginOptions & InternalCompressionPluginOptionsFunction<T>;
type ViteCompressionPluginConfigAlgorithm<A extends Algorithm> = BaseCompressionPluginOptions & InternalCompressionPluginOptionsAlgorithm<A>;
type ViteCompressionPluginConfig<T, A extends Algorithm> = ViteCompressionPluginConfigFunction<T> | ViteCompressionPluginConfigAlgorithm<A>;

declare function compression(): Plugin;
declare function compression<A extends Algorithm>(opts: ViteCompressionPluginConfigAlgorithm<A>): Plugin;
declare function compression<T = UserCompressionOptions>(opts: ViteCompressionPluginConfigFunction<T>): Plugin;

export { Algorithm, CompressionOptions, ViteCompressionPluginConfig, compression, compression as default };
