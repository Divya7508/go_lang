'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fsp = require('fs/promises');
var fs = require('fs');
var path = require('path');
var pluginutils = require('@rollup/pluginutils');
var zlib = require('zlib');

function len(source) {
    return source.length;
}
function replaceFileName(staticPath, rule) {
    const template = typeof rule === 'function' ? rule(staticPath) : rule;
    const { dir , base  } = path.parse(staticPath);
    const p = dir ? dir + '/' : '';
    return template.replace(/\[path\]/, p).replace(/\[base\]/, base);
}
function slash(path) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path);
    if (isExtendedLengthPath) return path;
    return path.replace(/\\/g, '/');
}
async function readAll(entry) {
    const paths = await Promise.all((await fsp.readdir(entry)).map((dir)=>path.join(entry, dir)));
    let pos = 0;
    const result = [];
    while(pos !== len(paths)){
        const dir = paths[pos];
        const stat = await fsp.stat(dir);
        if (stat.isDirectory()) {
            const dirs = await fsp.readdir(dir);
            paths.push(...dirs.map((sub)=>path.join(dir, sub)));
        }
        if (stat.isFile()) {
            result.push(dir);
        }
        pos++;
    }
    return result;
}

function ensureAlgorithm(userAlgorithm) {
    const algorithm = userAlgorithm in zlib ? userAlgorithm : 'gzip';
    return {
        algorithm: zlib[algorithm]
    };
}
function transfer(buf, compress, options) {
    return new Promise((resolve, reject)=>{
        compress(buf, options, (err, bf)=>{
            if (err) {
                reject(err);
                return;
            }
            if (!Buffer.isBuffer(bf)) {
                resolve(Buffer.from(bf));
            } else {
                resolve(bf);
            }
        });
    });
}
const defaultCompressionOptions = {
    gzip: {
        level: zlib.constants.Z_BEST_COMPRESSION
    },
    brotliCompress: {
        params: {
            [zlib.constants.BROTLI_PARAM_QUALITY]: zlib.constants.BROTLI_MAX_QUALITY
        }
    },
    deflate: {
        level: zlib.constants.Z_BEST_COMPRESSION
    },
    deflateRaw: {
        level: zlib.constants.Z_BEST_COMPRESSION
    }
};

class Queue {
    enqueue(task) {
        this.queue.push(task);
        this.run();
    }
    async run() {
        while(this.running < this.maxConcurrent && this.queue.length){
            const task = this.queue.shift();
            this.running++;
            try {
                await task();
            } finally{
                this.running--;
                this.run();
            }
        }
    }
    async wait() {
        while(this.running){
            await new Promise((resolve)=>setTimeout(resolve, 0));
        }
    }
    constructor(maxConcurrent){
        this.maxConcurrent = maxConcurrent;
        this.queue = [];
        this.running = 0;
    }
}
function createConcurrentQueue(max) {
    return new Queue(max);
}

const VITE_COPY_PUBLIC_DIR = 'copyPublicDir';
const MAX_CONCURRENT = 10;
function handleOutputOption(conf, outputs) {
    var _conf_build_rollupOptions;
    if ((_conf_build_rollupOptions = conf.build.rollupOptions) === null || _conf_build_rollupOptions === void 0 ? void 0 : _conf_build_rollupOptions.output) {
        const outputOptions = Array.isArray(conf.build.rollupOptions.output) ? conf.build.rollupOptions.output : [
            conf.build.rollupOptions.output
        ];
        outputOptions.forEach((opt)=>{
            if (typeof opt === 'object' && !len(Object.keys(opt))) return;
            outputs.push({
                dest: opt.dir || conf.build.outDir
            });
        });
        return;
    }
    outputs.push({
        dest: conf.build.outDir
    });
}
function makeOutputs(outputs, file) {
    const dests = [];
    const files = [];
    outputs.forEach(({ dest  })=>{
        dests.push(dest);
        files.push(slash(path.join(dest, file)));
    });
    return {
        dests,
        files
    };
}
function compression(opts = {}) {
    const { include , exclude , threshold =0 , algorithm: userAlgorithm = 'gzip' , filename , compressionOptions , deleteOriginalAssets =false , skipIfLargerOrEqual =false  } = opts;
    const filter = pluginutils.createFilter(include, exclude);
    const stores = new Map();
    const normalizedOutputs = [];
    const zlib = Object.create(null);
    zlib.algorithm = typeof userAlgorithm === 'string' ? ensureAlgorithm(userAlgorithm).algorithm : userAlgorithm;
    zlib.options = typeof userAlgorithm === 'function' ? compressionOptions : Object.assign(defaultCompressionOptions[userAlgorithm], compressionOptions);
    zlib.filename = filename !== null && filename !== void 0 ? filename : userAlgorithm === 'brotliCompress' ? '[path][base].br' : '[path][base].gz';
    const queue = createConcurrentQueue(MAX_CONCURRENT);
    return {
        name: 'vite-plugin-compression',
        apply: 'build',
        enforce: 'post',
        async configResolved (config) {
            handleOutputOption(config, normalizedOutputs);
            const baseCondit = VITE_COPY_PUBLIC_DIR in config.build ? config.build.copyPublicDir : true;
            if (config.publicDir && baseCondit && fs.existsSync(config.publicDir)) {
                const staticAssets = await readAll(config.publicDir);
                const publicPath = path.join(config.root, path.relative(config.root, config.publicDir));
                Promise.all(staticAssets.map(async (assets)=>{
                    if (!filter(assets)) return;
                    const { size  } = await fsp.stat(assets);
                    if (size < threshold) return;
                    const file = path.relative(publicPath, assets);
                    const { files , dests  } = makeOutputs(normalizedOutputs, file);
                    stores.set(slash(file), {
                        effect: true,
                        file: files,
                        dest: dests
                    });
                }));
            }
        },
        async generateBundle (_, bundles) {
            for(const fileName in bundles){
                if (!filter(fileName)) continue;
                const bundle = bundles[fileName];
                const result = bundle.type === 'asset' ? bundle.source : bundle.code;
                const size = len(result);
                if (size < threshold) continue;
                const meta = Object.create(null);
                if (bundle.type === 'chunk' && len(bundle.dynamicImports)) {
                    meta.effect = true;
                    const { dests , files  } = makeOutputs(normalizedOutputs, fileName);
                    if (meta.effect) {
                        meta.dest = dests;
                        meta.file = files;
                    }
                    const imports = bundle.dynamicImports;
                    imports.forEach((importer)=>{
                        if (!filter(importer)) return;
                        if (importer in bundles) {
                            const bundle = bundles[importer];
                            const chunk = bundle.type === 'asset' ? bundle.source : bundle.code;
                            if (len(chunk) < threshold) return;
                            const { dests , files  } = makeOutputs(normalizedOutputs, importer);
                            stores.set(importer, {
                                effect: true,
                                file: files,
                                dest: dests
                            });
                        }
                    });
                } else {
                    meta.effect = false;
                }
                if (!stores.has(fileName) && bundle) stores.set(fileName, meta);
            }
            const handle = async (file, meta)=>{
                if (meta.effect) return;
                const bundle = bundles[file];
                const fileName = replaceFileName(file, zlib.filename);
                if (file === fileName && bundle.type === 'chunk') {
                    const { dests , files  } = makeOutputs(normalizedOutputs, fileName);
                    stores.set(file, {
                        effect: true,
                        file: files,
                        dest: dests
                    });
                    return;
                }
                const source = Buffer.from(bundle.type === 'asset' ? bundle.source : bundle.code);
                const compressed = await transfer(source, zlib.algorithm, zlib.options);
                if (skipIfLargerOrEqual && len(compressed) >= len(source)) return;
                if (deleteOriginalAssets) Reflect.deleteProperty(bundles, file);
                this.emitFile({
                    type: 'asset',
                    source: compressed,
                    fileName
                });
                stores.delete(file);
            };
            try {
                for (const [file, meta1] of stores){
                    queue.enqueue(()=>handle(file, meta1));
                }
                await queue.wait();
            } catch (error) {
                 this.error(error);
            }
         },
        async closeBundle () {
            const handle = async (file, meta)=>{
                if (!meta.effect) return;
                for (const [pos, dest] of meta.dest.entries()){
                    const f = meta.file[pos];
                    const buf = await fsp.readFile(f);
                    const compressed = await transfer(buf, zlib.algorithm, zlib.options);
                    if (skipIfLargerOrEqual && len(compressed) >= len(buf)) continue;
                    const fileName = replaceFileName(file, zlib.filename);
                    const outputPath = path.join(dest, fileName);
                    if (deleteOriginalAssets && outputPath !== f) await fsp.rm(f, {
                        recursive: true,
                        force: true
                    });
                    await fsp.writeFile(outputPath, compressed);
                }
            };
            try {
                for (const [file, meta] of stores){
                    queue.enqueue(()=>handle(file, meta));
                }
                await queue.wait();
            } catch (error) {
             }
            stores.clear();
        }
    };
}

exports.compression = compression;
exports.default = compression;
